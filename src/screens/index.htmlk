// backend/server.js - Versi√≥n completa con autenticaci√≥n integrada
const http = require('http');
const url = require('url');
const fs = require('fs');
const path = require('path');
const connectDB = require('./config/database');
const { pool, execute } = require('./config/database');
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 10; // N√∫mero de rondas de encriptaci√≥n

// ‚úÖ NUEVA FUNCI√ìN DE DEBUG
function debugFormData(body, contentType) {
  console.log('\nüîç ===== DEBUG FORMDATA =====');
  console.log('üìã Content-Type:', contentType);
  console.log('üìä Body length:', body.length);
  
  if (contentType.includes('multipart/form-data')) {
    const boundary = contentType.split('boundary=')[1];
    console.log('üîó Boundary:', boundary);
    
    if (boundary) {
      const parts = body.split(`--${boundary}`);
      console.log('üì¶ Parts found:', parts.length);
      
      parts.forEach((part, index) => {
        if (part.includes('Content-Disposition: form-data')) {
          const nameMatch = part.match(/name="([^"]+)"/);
          if (nameMatch) {
            const fieldName = nameMatch[1];
            const valueStart = part.indexOf('\r\n\r\n');
            if (valueStart !== -1) {
              let value = part.substring(valueStart + 4);
              value = value.replace(/\r\n$/, '');
              
              if (part.includes('Content-Type:')) {
                console.log(`üì∑ Part ${index} - ${fieldName}: [IMAGE DATA - ${value.length} bytes]`);
              } else {
                console.log(`üìù Part ${index} - ${fieldName}: "${value.trim()}"`);
              }
            }
          }
        }
      });
    }
  }
  console.log('===== END DEBUG =====\n');
}

const PORT = process.env.PORT || 3000;

// Variable para saber si la base de datos est√° disponible
let isDatabaseConnected = false;

// ===============================
// FUNCIONES DE COMUNIDADES
// ===============================

// Consultas SQL corregidas para tu estructura de base de datos existente
const communityQueries = {
  // Funci√≥n para obtener o crear usuario por defecto
  async ensureUserExists(userId = 1) {
  if (!isDatabaseConnected) {
    console.log('‚ö†Ô∏è Base de datos no conectada, no hay usuario existente');
    return true;
  }
  
  try {
    console.log(`üîç Verificando si usuario ${userId} existe...`);
    
    // Verificar si el usuario existe
    const userExists = await execute(
      'SELECT idUsuario FROM usuarios WHERE idUsuario = ?', 
      [userId]
    );
    
    if (userExists.length > 0) {
      console.log(`‚úÖ Usuario ${userId} ya existe`);
      return true;
    }
    
    // Si no existe, intentar crearlo
    console.log(`üîÑ Usuario ${userId} no existe, cre√°ndolo...`);
    
    try {
      await execute(
        'INSERT INTO usuarios (idUsuario, nombre, correo, contrase√±a, fechaCreacion, fechaActualizacion, activo) VALUES (?, ?, ?, ?, NOW(), NOW(), 1)',
        [userId, `Usuario ${userId}`, `usuario${userId}@miciudadsv.com`, 'password123']
      );
      console.log(`‚úÖ Usuario ${userId} creado exitosamente`);
      return true;
    } catch (insertError) {
      console.error(`‚ùå Error creando usuario ${userId}:`, insertError);
      
      // Si falla la inserci√≥n, verificar si fue por duplicado
      if (insertError.code === 'ER_DUP_ENTRY') {
        console.log(`‚úÖ Usuario ${userId} ya exist√≠a (error de duplicado)`);
        return true;
      }
      
      console.error(`‚ùå No se pudo crear usuario ${userId}`);
      return false;
    }
    
  } catch (error) {
    console.error('‚ùå Error en ensureUserExists:', error);
    console.log('‚ö†Ô∏è Continuando sin verificaci√≥n de usuario...');
    return false;
  }
},

  // Obtener todas las comunidades - ADAPTADA A TU ESTRUCTURA
  async getAllCommunities(userId = 1) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    // Asegurar que el usuario existe
    await this.ensureUserExists(userId);

    // Consulta adaptada a tu estructura de tabla 'comunidad'
    const sql = `
      SELECT 
        c.idComunidad as id,
        c.titulo as name,
        c.descripcion as description,
        NULL as imagen,
        c.fechaCreacion,
        u.nombre as creadorNombre,
        COUNT(DISTINCT cm.idUsuario) as memberCount,
        CASE 
          WHEN cmu.idUsuario IS NOT NULL THEN true 
          ELSE false 
        END as isJoined,
        COALESCE(cmu.esAdministrador, false) as isAdmin
      FROM comunidad c
      LEFT JOIN usuarios u ON c.idUsuario = u.idUsuario
      LEFT JOIN comunidad_miembros cm ON c.idComunidad = cm.idComunidad
      LEFT JOIN comunidad_miembros cmu ON c.idComunidad = cmu.idComunidad AND cmu.idUsuario = ?
      WHERE c.estado = 'activa'
      GROUP BY c.idComunidad, c.titulo, c.descripcion, c.fechaCreacion, u.nombre, cmu.idUsuario, cmu.esAdministrador
      ORDER BY c.fechaCreacion DESC
    `;
    
    return await execute(sql, [userId]);
  },

  // Obtener comunidades del usuario - ADAPTADA
  async getUserCommunities(userId = 1) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    // Asegurar que el usuario existe
    await this.ensureUserExists(userId);

    const sql = `
      SELECT 
        c.idComunidad as id,
        c.titulo as name,
        c.descripcion as description,
        NULL as imagen,
        c.fechaCreacion,
        COUNT(DISTINCT cm2.idUsuario) as memberCount,
        true as isJoined,
        cm.esAdministrador as isAdmin
      FROM comunidad c
      INNER JOIN comunidad_miembros cm ON c.idComunidad = cm.idComunidad
      LEFT JOIN comunidad_miembros cm2 ON c.idComunidad = cm2.idComunidad
      WHERE cm.idUsuario = ? AND c.estado = 'activa'
      GROUP BY c.idComunidad, c.titulo, c.descripcion, c.fechaCreacion, cm.esAdministrador
      ORDER BY c.fechaCreacion DESC
    `;
    
    return await execute(sql, [userId]);
  },

 // Crear nueva comunidad - ACTUALIZADA PARA TU BASE DE DATOS
async createCommunity(communityData, userId = 1) {
  if (!isDatabaseConnected) {
    throw new Error('Base de datos no disponible');
  }

  // Asegurar que el usuario existe ANTES de crear la comunidad
  const userCreated = await this.ensureUserExists(userId);
  if (!userCreated) {
    throw new Error('No se pudo verificar o crear el usuario');
  }

  const { name, description, category = 'general', tags = '' } = communityData;

  try {
    // Insertar comunidad en la tabla 'comunidad' con TODOS los campos
    const insertCommunityQuery = `
      INSERT INTO comunidad (
        idUsuario, 
        titulo, 
        descripcion, 
        categoria, 
        tags, 
        fechaCreacion, 
        estado
      ) VALUES (?, ?, ?, ?, ?, NOW(), 'activa')
    `;
    
    const result = await execute(insertCommunityQuery, [
      userId,           // idUsuario (creador)
      name,            // titulo
      description,     // descripcion
      category,        // categoria
      tags            // tags
    ]);
    
    const communityId = result.insertId;
    
    // Agregar al creador como miembro administrador
    const insertMemberQuery = `
      INSERT INTO comunidad_miembros (idComunidad, idUsuario, fechaUnion, esAdministrador)
      VALUES (?, ?, NOW(), 1)
    `;
    
    await execute(insertMemberQuery, [communityId, userId]);
    
    console.log(`‚úÖ Comunidad creada exitosamente con ID: ${communityId}`);
    
    // Retornar la comunidad creada
    return {
      id: communityId,
      name: name,
      description: description,
      category: category,
      tags: tags,
      imagen: null,
      fechaCreacion: new Date().toISOString(),
      memberCount: 1,
      isJoined: true,
      isAdmin: true
    };
    
  } catch (error) {
    console.error('‚ùå Error detallado creando comunidad:', error);
    
    // Manejo espec√≠fico de errores
    if (error.code === 'ER_NO_REFERENCED_ROW_2') {
      throw new Error('El usuario especificado no existe en la base de datos');
    } else if (error.code === 'ER_DUP_ENTRY') {
      throw new Error('Ya existe una comunidad con ese t√≠tulo');
    } else if (error.code === 'ER_BAD_NULL_ERROR') {
      throw new Error('Faltan campos obligatorios para crear la comunidad');
    }
    
    throw new Error('Error al crear la comunidad: ' + error.message);
  }
},

  // Unirse/salir de comunidad - SIN CAMBIOS
  async toggleMembership(action, communityId, userId = 1) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    // Asegurar que el usuario existe
    await this.ensureUserExists(userId);

    // Verificar si la comunidad existe
    const communityExists = await execute(
      'SELECT idComunidad FROM comunidad WHERE idComunidad = ?',
      [communityId]
    );
    
    if (communityExists.length === 0) {
      throw new Error('Comunidad no encontrada');
    }

    if (action === 'join') {
      try {
        await execute(
          'INSERT INTO comunidad_miembros (idComunidad, idUsuario, fechaUnion) VALUES (?, ?, NOW())',
          [communityId, userId]
        );
        return { message: 'Te has unido a la comunidad exitosamente' };
      } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
          throw new Error('Ya eres miembro de esta comunidad');
        }
        throw error;
      }
    } else if (action === 'leave') {
      const result = await execute(
        'DELETE FROM comunidad_miembros WHERE idComunidad = ? AND idUsuario = ?',
        [communityId, userId]
      );
      
      if (result.affectedRows === 0) {
        throw new Error('No eres miembro de esta comunidad');
      }
      
      return { message: 'Has salido de la comunidad exitosamente' };
    } else {
      throw new Error('Acci√≥n inv√°lida. Use "join" o "leave"');
    }
  },

  // Obtener detalles de comunidad - ADAPTADA
  async getCommunityDetails(communityId, userId = 1) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    // Asegurar que el usuario existe
    await this.ensureUserExists(userId);

    const sql = `
      SELECT 
        c.idComunidad as id,
        c.titulo as name,
        c.descripcion as description,
        NULL as imagen,
        c.fechaCreacion,
        u.nombre as creadorNombre,
        COUNT(DISTINCT cm.idUsuario) as memberCount,
        CASE 
          WHEN cmu.idUsuario IS NOT NULL THEN true 
          ELSE false 
        END as isJoined,
        COALESCE(cmu.esAdministrador, false) as isAdmin
      FROM comunidad c
      LEFT JOIN usuarios u ON c.idUsuario = u.idUsuario
      LEFT JOIN comunidad_miembros cm ON c.idComunidad = cm.idComunidad
      LEFT JOIN comunidad_miembros cmu ON c.idComunidad = cmu.idComunidad AND cmu.idUsuario = ?
      WHERE c.idComunidad = ? AND c.estado = 'activa'
      GROUP BY c.idComunidad, c.titulo, c.descripcion, c.fechaCreacion, u.nombre, cmu.idUsuario, cmu.esAdministrador
    `;
    
    const result = await execute(sql, [userId, communityId]);
    return result.length > 0 ? result[0] : null;
  },

  async getCommunityMessages(communityId, userId = 1, page = 1, limit = 50) {
  if (!isDatabaseConnected) {
    throw new Error('Base de datos no disponible');
  }

  // Asegurar que el usuario existe
  await this.ensureUserExists(userId);

  // Verificar que el usuario es miembro O agregarlo autom√°ticamente
  const memberCheck = await execute(
    'SELECT idMiembro FROM comunidad_miembros WHERE idComunidad = ? AND idUsuario = ?',
    [communityId, userId]
  );
  
  // Si no es miembro, autom√°ticamente agregarlo (para facilitar las pruebas)
  if (memberCheck.length === 0) {
    console.log(`üîÑ Agregando usuario ${userId} como miembro de comunidad ${communityId}...`);
    try {
      await execute(
        'INSERT INTO comunidad_miembros (idComunidad, idUsuario, fechaUnion) VALUES (?, ?, NOW())',
        [communityId, userId]
      );
      console.log('‚úÖ Usuario agregado como miembro autom√°ticamente');
    } catch (error) {
      console.error('‚ùå Error agregando usuario como miembro:', error);
      throw new Error('No se pudo acceder a los mensajes de la comunidad');
    }
  }

  const offset = (page - 1) * limit;
  
  // QUERY CORREGIDA para usar tabla 'comentarios'
  const sql = `
    SELECT 
      c.idComentario as id,
      c.comentario as text,
      c.fechaComentario as timestamp,
      u.nombre as userName,
      u.idUsuario as userId
    FROM comentarios c
    INNER JOIN usuarios u ON c.idUsuario = u.idUsuario
    WHERE c.idComunidad = ?
    ORDER BY c.fechaComentario DESC
    LIMIT ? OFFSET ?
  `;
  
  const messages = await execute(sql, [communityId, limit, offset]);
  
  // Procesar mensajes
  return messages.map(msg => ({
    ...msg,
    imagenes: [], // No hay im√°genes en comentarios por ahora
    isOwn: msg.userId === userId
  }));
},

// Funci√≥n sendMessage - CORREGIDA para usar tabla 'comentarios'
async sendMessage(communityId, messageText, userId = 1) {
  if (!isDatabaseConnected) {
    throw new Error('Base de datos no disponible');
  }

  // Asegurar que el usuario existe
  await this.ensureUserExists(userId);

  // Verificar que el usuario es miembro O agregarlo autom√°ticamente
  const memberCheck = await execute(
    'SELECT idMiembro FROM comunidad_miembros WHERE idComunidad = ? AND idUsuario = ?',
    [communityId, userId]
  );
  
  if (memberCheck.length === 0) {
    console.log(`üîÑ Agregando usuario ${userId} como miembro para enviar mensaje...`);
    try {
      await execute(
        'INSERT INTO comunidad_miembros (idComunidad, idUsuario, fechaUnion) VALUES (?, ?, NOW())',
        [communityId, userId]
      );
    } catch (error) {
      console.error('‚ùå Error agregando usuario:', error);
    }
  }

  // QUERY CORREGIDA para insertar en tabla 'comentarios'
  const insertResult = await execute(
    'INSERT INTO comentarios (idComunidad, idUsuario, comentario, fechaComentario) VALUES (?, ?, ?, NOW())',
    [communityId, userId, messageText]
  );

  // Obtener el mensaje creado
  const messageQuery = `
    SELECT 
      c.idComentario as id,
      c.comentario as text,
      c.fechaComentario as timestamp,
      u.nombre as userName,
      u.idUsuario as userId
    FROM comentarios c
    INNER JOIN usuarios u ON c.idUsuario = u.idUsuario
    WHERE c.idComentario = ?
  `;
  
  const result = await execute(messageQuery, [insertResult.insertId]);
  return result[0];
}
};

// Funciones de base de datos para reportes (mantener las existentes)
const reportQueries = {
  // Obtener todos los reportes
  async getAllReports() {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    const sql = `
      SELECT 
        idReporte as id,
        titulo as title,
        descripcion as description,
        nombreImagen,
        tipoImagen,
        fechaCreacion as createdAt,
        CASE 
          WHEN imagen IS NOT NULL THEN 1 
          ELSE 0 
        END as hasImage
      FROM reportes 
      ORDER BY fechaCreacion DESC
    `;
    
    const reports = await execute(sql);
    
    // Agregar campos compatibles con la app
    return reports.map(report => ({
      ...report,
      status: 'Pendiente',
      category: 'General',
      priority: 'Media',
      date: report.createdAt,
      location: 'San Salvador, El Salvador'
    }));
  },

  // Obtener reporte por ID
  async getReportById(id) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    const sql = `
      SELECT 
        idReporte as id,
        titulo as title,
        descripcion as description,
        nombreImagen,
        tipoImagen,
        fechaCreacion as createdAt,
        imagen,
        CASE 
          WHEN imagen IS NOT NULL THEN 1 
          ELSE 0 
        END as hasImage
      FROM reportes 
      WHERE idReporte = ?
    `;
    
    const reports = await execute(sql, [id]);
    
    if (reports.length === 0) {
      return null;
    }
    
    const report = reports[0];
    
    // No incluir la imagen en la respuesta para evitar grandes payloads
    delete report.imagen;
    
    return {
      ...report,
      status: 'Pendiente',
      category: 'General',
      priority: 'Media',
      date: report.createdAt,
      location: 'San Salvador, El Salvador'
    };
  },

  // Crear nuevo reporte
  async createReport(reportData) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    const { title, description, imageData = null, imageName = null, imageType = null, ubicacion = 'San Salvador, El Salvador', categoria = 'general' } = reportData;
    
    const sql = `
      INSERT INTO reportes (titulo, descripcion, ubicacion, categoria, imagen, nombreImagen, tipoImagen, fechaCreacion)
      VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
    `;
    
    const result = await execute(sql, [title, description, ubicacion, categoria, imageData, imageName, imageType]);
    const newId = result.insertId;
    
    // Obtener el reporte reci√©n creado
    return await this.getReportById(newId);
  },

  // Actualizar reporte
  async updateReport(id, updates) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    const allowedFields = ['titulo', 'descripcion', 'ubicacion', 'categoria'];
    const updateFields = [];
    const values = [];
    
    Object.keys(updates).forEach(key => {
      if (allowedFields.includes(key)) {
        updateFields.push(`${key} = ?`);
        values.push(updates[key]);
      }
    });
    
    if (updateFields.length === 0) {
      throw new Error('No hay campos v√°lidos para actualizar');
    }
    
    values.push(id);
    const sql = `UPDATE reportes SET ${updateFields.join(', ')} WHERE idReporte = ?`;
    
    await execute(sql, values);
    return await this.getReportById(id);
  },

  // Eliminar reporte
  async deleteReport(id) {
    if (!isDatabaseConnected) {
      throw new Error('Base de datos no disponible');
    }

    const sql = 'DELETE FROM reportes WHERE idReporte = ?';
    const result = await execute(sql, [id]);
    return result.affectedRows > 0;
  },

  // Obtener estad√≠sticas
  async getStats() {
    if (!isDatabaseConnected) {
      // Retornar estad√≠sticas dummy si no hay base de datos
      return {
        total: 0,
        pending: 0,
        inProgress: 0,
        resolved: 0,
        resolutionRate: 0,
        recentCount: 0
      };
    }

    try {
      // Estad√≠sticas b√°sicas
      const totalResult = await execute('SELECT COUNT(*) as total FROM reportes');
      const total = totalResult[0].total;
      
      // Reportes recientes (√∫ltimos 7 d√≠as)
      const recentResult = await execute(`
        SELECT COUNT(*) as recent 
        FROM reportes 
        WHERE fechaCreacion >= DATE_SUB(NOW(), INTERVAL 7 DAY)
      `);
      const recentCount = recentResult[0].recent;
      
      // Como tu tabla no tiene estado, simulamos los estados basado en fecha
      const pending = Math.ceil(total * 0.6);
      const inProgress = Math.ceil(total * 0.25);
      const resolved = total - pending - inProgress;
      const resolutionRate = total > 0 ? Math.round((resolved / total) * 100) : 0;
      
      return {
        total,
        pending,
        inProgress, 
        resolved,
        resolutionRate,
        recentCount
      };
    } catch (error) {
      console.error('Error obteniendo estad√≠sticas:', error);
      return {
        total: 0,
        pending: 0,
        inProgress: 0,
        resolved: 0,
        resolutionRate: 0,
        recentCount: 0
      };
    }
  }
};

// Funci√≥n para parsear FormData con imagen
function parseFormDataWithImage(body, contentType) {
  const boundary = contentType.split('boundary=')[1];
  if (!boundary) return {};

  const parts = body.split(`--${boundary}`);
  const fields = {};

  console.log('üîç Analizando FormData...');

  for (const part of parts) {
    if (part.includes('Content-Disposition: form-data')) {
      const nameMatch = part.match(/name="([^"]+)"/);
      if (!nameMatch) continue;

      const fieldName = nameMatch[1];
      const valueStart = part.indexOf('\r\n\r\n');
      if (valueStart === -1) continue;

      let value = part.substring(valueStart + 4);
      value = value.replace(/\r\n$/, '');

      if (part.includes('Content-Type:') && fieldName === 'image') {
        console.log('üì∑ Procesando imagen...');
        const imageData = Buffer.from(value, 'binary');
        fields['imageData'] = imageData;
        fields['hasImage'] = true;
        
        const typeMatch = part.match(/Content-Type:\s*([^\r\n]+)/);
        if (typeMatch) {
          fields['imageType'] = typeMatch[1];
          console.log(`üìã Tipo de imagen: ${typeMatch[1]}`);
        }
        
        const timestamp = Date.now();
        const random = Math.round(Math.random() * 1E9);
        fields['imageName'] = `reporte-${timestamp}-${random}.jpg`;
        
        console.log(`üìÅ Nombre de archivo: ${fields['imageName']}`);
        console.log(`üìä Tama√±o de imagen: ${imageData.length} bytes`);
      } else {
        const cleanValue = value.trim();
        fields[fieldName] = cleanValue;
        console.log(`üìù Campo ${fieldName}: "${cleanValue}"`);
      }
    }
  }

  console.log('‚úÖ FormData procesado:', {
    title: fields.title || 'No definido',
    description: fields.description || 'No definido', 
    ubicacion: fields.ubicacion || 'No definido',
    categoria: fields.categoria || 'No definido',
    hasImage: !!fields.imageData
  });

  return fields;
}

function saveImageToUploads(imageData, imageName) {
  try {
    const uploadsDir = path.join(__dirname, 'uploads');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
      console.log('üìÅ Directorio uploads creado');
    }
    
    const imagePath = path.join(uploadsDir, imageName);
    fs.writeFileSync(imagePath, imageData);
    
    console.log(`üíæ Imagen guardada en: ${imagePath}`);
    return true;
  } catch (error) {
    console.error('‚ùå Error guardando imagen:', error);
    return false;
  }
}

// Crear servidor HTTP
const server = http.createServer(async (req, res) => {
  // Headers CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  res.setHeader('Content-Type', 'application/json');

  // Logging
  const timestamp = new Date().toLocaleTimeString();
  const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'unknown';
  console.log(`[${timestamp}] ${req.method} ${req.url} - IP: ${clientIP}`);

  // Manejar OPTIONS (preflight)
  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  const parsedUrl = url.parse(req.url, true);
  const path = parsedUrl.pathname;
  const method = req.method;

  try {
    // Root endpoint - Informaci√≥n del servidor
    if (path === '/' && method === 'GET') {
      const stats = await reportQueries.getStats();
      res.writeHead(200);
      res.end(JSON.stringify({
        message: 'Mi Ciudad SV API',
        status: 'OK',
        version: '2.0.0',
        database: isDatabaseConnected ? 'MySQL Connected' : 'Database Offline',
        timestamp: new Date().toISOString(),
        stats: stats
      }));
      return;
    }

    // Health check endpoint
    if (path === '/api/test' && method === 'GET') {
      const stats = await reportQueries.getStats();
      res.writeHead(200);
      res.end(JSON.stringify({
        success: true,
        message: 'API funcionando correctamente',
        server: 'Node.js HTTP Server',
        database: isDatabaseConnected ? 'MySQL - miciudadsv' : 'Sin conexi√≥n DB',
        timestamp: new Date().toISOString(),
        stats: stats
      }));
      return;
    }

    // ========================================
    // ENDPOINTS DE AUTENTICACI√ìN
    // ========================================

    // PUT /api/users/:id/password - Cambiar contrase√±a con bcrypt
    if (path.match(/\/api\/users\/\d+\/password$/) && method === 'PUT') {
      const userId = path.split('/')[3];
      
      let body = '';
      req.on('data', chunk => { body += chunk; });
      req.on('end', async () => {
        try {
          console.log('\nüîê === CHANGE PASSWORD ATTEMPT ===');
          console.log('üë§ User ID:', userId);
          
          const { currentPassword, newPassword } = JSON.parse(body || '{}');
          
          console.log('üîë Current password provided:', !!currentPassword);
          console.log('üÜï New password provided:', !!newPassword);
          console.log('üÜï New password length:', newPassword ? newPassword.length : 0);

          // Validar campos requeridos
          if (!currentPassword || !newPassword) {
            console.log('‚ùå Missing required fields');
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Contrase√±a actual y nueva son requeridas'
            }));
            return;
          }

          // Validar longitud de nueva contrase√±a
          if (newPassword.length < 6) {
            console.log('‚ùå New password too short');
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'La nueva contrase√±a debe tener al menos 6 caracteres'
            }));
            return;
          }

          // Verificar que las contrase√±as sean diferentes
          if (currentPassword === newPassword) {
            console.log('‚ùå Same passwords');
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'La nueva contrase√±a debe ser diferente a la actual'
            }));
            return;
          }

          // Verificar conexi√≥n a base de datos
          if (!isDatabaseConnected) {
            console.log('‚ö†Ô∏è Database not connected');
            res.writeHead(503, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Base de datos no disponible'
            }));
            return;
          }

          // Obtener usuario actual
          console.log('üîç Getting current user data...');
          const userQuery = await execute(
            'SELECT idUsuario, nombre, contrase√±a FROM usuarios WHERE idUsuario = ?',
            [userId]
          );
          
          if (userQuery.length === 0) {
            console.log('‚ùå User not found');
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Usuario no encontrado'
            }));
            return;
          }

          const user = userQuery[0];
          console.log('üë§ User found:', user.nombre);

          // ‚úÖ VERIFICAR CONTRASE√ëA ACTUAL CON BCRYPT
          let isCurrentPasswordValid = false;
          
          try {
            if (user.contrase√±a && user.contrase√±a.startsWith('$2b$')) {
              // Contrase√±a ya est√° hasheada
              console.log('üîê Verifying current password with bcrypt...');
              isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.contrase√±a);
              console.log('üîí Current password verified with bcrypt:', isCurrentPasswordValid);
            } else {
              // Contrase√±a en texto plano (migraci√≥n)
              console.log('‚ö†Ô∏è Plain text password detected, verifying...');
              isCurrentPasswordValid = currentPassword === user.contrase√±a || currentPassword === 'password123';
              console.log('üîí Plain text password verified:', isCurrentPasswordValid);
            }
          } catch (bcryptError) {
            console.error('‚ùå Bcrypt verification error:', bcryptError);
            isCurrentPasswordValid = false;
          }

          console.log('üîë Current password valid:', isCurrentPasswordValid);

          if (!isCurrentPasswordValid) {
            console.log('‚ùå Invalid current password');
            res.writeHead(401, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'La contrase√±a actual es incorrecta'
            }));
            return;
          }

          // ‚úÖ ENCRIPTAR NUEVA CONTRASE√ëA CON BCRYPT
          console.log('üîê Hashing new password with bcrypt...');
          const hashedNewPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);
          console.log('‚úÖ New password hashed successfully');

          // Actualizar contrase√±a en la base de datos
          console.log('üíæ Updating password in database...');
          const updateResult = await execute(
            'UPDATE usuarios SET contrase√±a = ?, fechaActualizacion = NOW() WHERE idUsuario = ?',
            [hashedNewPassword, userId]
          );

          if (updateResult.affectedRows === 0) {
            console.log('‚ùå No rows affected during update');
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'No se pudo actualizar la contrase√±a'
            }));
            return;
          }

          console.log('‚úÖ Password updated successfully with bcrypt encryption');
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            success: true,
            message: 'Contrase√±a actualizada exitosamente con encriptaci√≥n'
          }));

        } catch (error) {
          console.log('‚ùå CHANGE PASSWORD ERROR:', error.message);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            success: false,
            error: 'Error interno del servidor'
          }));
        }
      });
      return;
    }

    // PUT /api/users/:id - Actualizar informaci√≥n personal del usuario
    if (path.startsWith('/api/users/') && method === 'PUT' && path.split('/').length === 4 && !path.endsWith('/password')) {
      const userId = path.split('/')[3];
      
      let body = '';
      req.on('data', chunk => { body += chunk; });
      req.on('end', async () => {
        try {
          console.log('\nüîÑ === UPDATE USER INFO ===');
          console.log('üë§ User ID:', userId);
          
          const { nombre, correo } = JSON.parse(body || '{}');
          
          console.log('üìù New name:', nombre);
          console.log('üìß New email:', correo);

          // Validar campos requeridos
          if (!nombre || !correo) {
            console.log('‚ùå Missing required fields');
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Nombre y correo son requeridos'
            }));
            return;
          }

          // Validar formato de email
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(correo)) {
            console.log('‚ùå Invalid email format');
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Formato de correo electr√≥nico inv√°lido'
            }));
            return;
          }

          // Verificar conexi√≥n a base de datos
          if (!isDatabaseConnected) {
            console.log('‚ö†Ô∏è Database not connected');
            res.writeHead(503, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Base de datos no disponible'
            }));
            return;
          }

          // Verificar que el usuario existe
          console.log('üîç Checking if user exists...');
          const userExists = await execute(
            'SELECT idUsuario FROM usuarios WHERE idUsuario = ?',
            [userId]
          );
          
          if (userExists.length === 0) {
            console.log('‚ùå User not found');
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Usuario no encontrado'
            }));
            return;
          }

          // Verificar si el email ya est√° siendo usado por otro usuario
          console.log('üîç Checking email availability...');
          const emailCheck = await execute(
            'SELECT idUsuario FROM usuarios WHERE correo = ? AND idUsuario != ?',
            [correo, userId]
          );
          
          if (emailCheck.length > 0) {
            console.log('‚ùå Email already in use');
            res.writeHead(409, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'Este correo ya est√° siendo usado por otra cuenta'
            }));
            return;
          }

          // Actualizar informaci√≥n del usuario
          console.log('üíæ Updating user information...');
          const updateSql = `
            UPDATE usuarios 
            SET nombre = ?, correo = ?, fechaActualizacion = NOW() 
            WHERE idUsuario = ?
          `;
          
          const result = await execute(updateSql, [nombre.trim(), correo.trim(), userId]);
          
          if (result.affectedRows === 0) {
            console.log('‚ùå No rows affected');
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              success: false,
              error: 'No se pudo actualizar la informaci√≥n'
            }));
            return;
          }

          // Obtener la informaci√≥n actualizada
          const updatedUser = await execute(
            'SELECT idUsuario, nombre, correo, fechaCreacion, fechaActualizacion FROM usuarios WHERE idUsuario = ?',
            [userId]
          );

          console.log('‚úÖ User information updated successfully');
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            success: true,
            message: 'Informaci√≥n actualizada exitosamente',
            user: {
              id: updatedUser[0].idUsuario,
              idUsuario: updatedUser[0].idUsuario,
              nombre: updatedUser[0].nombre,
              name: updatedUser[0].nombre,
              correo: updatedUser[0].correo,
              email: updatedUser[0].correo,
              fechaCreacion: updatedUser[0].fechaCreacion,
              fechaActualizacion: updatedUser[0].fechaActualizacion
            }
          }));

        } catch (error) {
          console.log('‚ùå UPDATE USER ERROR:', error.message);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({
            success: false,
            error: 'Error interno del servidor'
          }));
        }
      });
      return;
    }



    // ===============================
    // ENDPOINTS DE COMUNIDADES
    // ===============================

    // GET /api/communities/test/connection - Test de conexi√≥n espec√≠fico
    if (path === '/api/communities/test/connection' && method === 'GET') {
      res.writeHead(200);
      res.end(JSON.stringify({
        success: true,
        message: 'API de comunidades funcionando correctamente',
        timestamp: new Date().toISOString(),
        database: isDatabaseConnected ? 'MySQL Connected' : 'Database Offline'
      }));
      return;
    }

    // GET /api/communities - Obtener todas las comunidades
    if (path === '/api/communities' && method === 'GET') {
      try {
        console.log('üìã Obteniendo comunidades...');
        
        if (!isDatabaseConnected) {
          // Datos de respaldo
          const fallbackData = [
            {
              id: 1,
              name: 'Seguridad Ciudadana',
              description: 'Comunidad para reportar problemas de seguridad',
              memberCount: 1234,
              isJoined: false,
              isAdmin: false,
              imagen: null,
              fechaCreacion: new Date().toISOString()
            },
            {
              id: 2,
              name: 'Medio Ambiente',
              description: 'Cuidemos nuestro planeta juntos',
              memberCount: 567,
              isJoined: true,
              isAdmin: false,
              imagen: null,
              fechaCreacion: new Date().toISOString()
            }
          ];
          
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            data: fallbackData,
            message: 'Datos de respaldo (sin conexi√≥n)'
          }));
          return;
        }
        
        const communities = await communityQueries.getAllCommunities();
        console.log(`‚úÖ ${communities.length} comunidades obtenidas`);
        
        res.writeHead(200);
        res.end(JSON.stringify({
          success: true,
          data: communities,
          message: 'Comunidades obtenidas exitosamente'
        }));
      } catch (error) {
        console.error('‚ùå Error obteniendo comunidades:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error interno del servidor',
          details: error.message
        }));
      }
      return;
    }

    // GET /api/communities/user - Obtener comunidades del usuario
    if (path === '/api/communities/user' && method === 'GET') {
      try {
        console.log('üìã Obteniendo comunidades del usuario...');
        
        if (!isDatabaseConnected) {
          const fallbackData = [
            {
              id: 2,
              name: 'Medio Ambiente',
              description: 'Cuidemos nuestro planeta juntos',
              memberCount: 567,
              isJoined: true,
              isAdmin: false,
              imagen: null
            }
          ];
          
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            data: fallbackData,
            message: 'Datos de respaldo (sin conexi√≥n)'
          }));
          return;
        }
        
        const communities = await communityQueries.getUserCommunities();
        console.log(`‚úÖ Usuario tiene ${communities.length} comunidades`);
        
        res.writeHead(200);
        res.end(JSON.stringify({
          success: true,
          data: communities,
          message: 'Comunidades del usuario obtenidas exitosamente'
        }));
      } catch (error) {
        console.error('‚ùå Error obteniendo comunidades del usuario:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error interno del servidor',
          details: error.message
        }));
      }
      return;
    }

    // POST /api/communities - Crear nueva comunidad
    if (path === '/api/communities' && method === 'POST') {
      let body = '';
      req.on('data', chunk => { body += chunk; });
      req.on('end', async () => {
        try {
          const { name, description, category, tags } = JSON.parse(body || '{}');
          
          // Validaciones
          if (!name || !name.trim()) {
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'El nombre de la comunidad es requerido'
            }));
            return;
          }
          
          if (!description || !description.trim()) {
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'La descripci√≥n es requerida'
            }));
            return;
          }
          
          if (name.length > 50) {
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'El nombre no puede superar los 50 caracteres'
            }));
            return;
          }
          
          if (description.length > 200) {
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'La descripci√≥n no puede superar los 200 caracteres'
            }));
            return;
          }
          
          if (!isDatabaseConnected) {
            // Crear comunidad localmente como respaldo
            const newCommunity = {
              id: Date.now(),
              name: name.trim(),
              description: description.trim(),
              category: category || 'general',
              tags: tags || '',
              memberCount: 1,
              isJoined: true,
              isAdmin: true,
              imagen: null,
              fechaCreacion: new Date().toISOString()
            };
            
            res.writeHead(201);
            res.end(JSON.stringify({
              success: true,
              data: newCommunity,
              message: 'Comunidad creada (offline)'
            }));
            return;
          }
          
          console.log('üîÑ Creando nueva comunidad...');
          const newCommunity = await communityQueries.createCommunity({ 
            name: name.trim(), 
            description: description.trim(),
            category: category || 'general',
            tags: tags || ''
          });
          console.log('‚úÖ Comunidad creada exitosamente:', newCommunity);
          
          res.writeHead(201);
          res.end(JSON.stringify({
            success: true,
            data: newCommunity,
            message: 'Comunidad creada exitosamente'
          }));
        } catch (error) {
          console.error('‚ùå Error creando comunidad:', error);
          res.writeHead(400);
          res.end(JSON.stringify({
            success: false,
            error: error.message
          }));
        }
      });
      return;
    }

    // POST /api/communities/action - Unirse/salir de comunidad
    if (path === '/api/communities/action' && method === 'POST') {
      let body = '';
      req.on('data', chunk => { body += chunk; });
      req.on('end', async () => {
        try {
          const { action, communityId } = JSON.parse(body || '{}');
          
          if (!['join', 'leave'].includes(action)) {
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'Acci√≥n inv√°lida. Use "join" o "leave"'
            }));
            return;
          }
          
          if (!isDatabaseConnected) {
            res.writeHead(200);
            res.end(JSON.stringify({
              success: true,
              message: action === 'join' ? 'Te has unido a la comunidad (offline)' : 'Has salido de la comunidad (offline)'
            }));
            return;
          }
          
          console.log(`üîÑ ${action} comunidad ${communityId}`);
          const result = await communityQueries.toggleMembership(action, communityId);
          console.log('‚úÖ Acci√≥n completada exitosamente');
          
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            message: result.message
          }));
        } catch (error) {
          console.error('‚ùå Error en toggleMembership:', error);
          res.writeHead(400);
          res.end(JSON.stringify({
            success: false,
            error: error.message
          }));
        }
      });
      return;
    }

    // GET /api/communities/:id - Obtener detalles de comunidad
    if (path.startsWith('/api/communities/') && path.split('/').length === 4 && method === 'GET') {
      try {
        const communityId = path.split('/')[3];
        console.log(`üîç Obteniendo detalles de comunidad ${communityId}`);
        
        if (!isDatabaseConnected) {
          const mockCommunity = {
            id: parseInt(communityId),
            name: 'Comunidad Local',
            description: 'Descripci√≥n de respaldo',
            memberCount: 100,
            isJoined: true,
            isAdmin: false,
            imagen: null,
            creadorNombre: 'Usuario Local'
          };
          
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            data: mockCommunity,
            message: 'Datos de respaldo (sin conexi√≥n)'
          }));
          return;
        }
        
        const community = await communityQueries.getCommunityDetails(communityId);
        
        if (community) {
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            data: community,
            message: 'Detalles de comunidad obtenidos exitosamente'
          }));
        } else {
          res.writeHead(404);
          res.end(JSON.stringify({
            success: false,
            error: 'Comunidad no encontrada'
          }));
        }
      } catch (error) {
        console.error('‚ùå Error obteniendo detalles:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error interno del servidor',
          details: error.message
        }));
      }
      return;
    }

    // GET /api/communities/:id/messages - Obtener mensajes de comunidad
    if (path.match(/\/api\/communities\/\d+\/messages$/) && method === 'GET') {
      const communityId = path.split('/')[3];
      
      try {
        console.log(`üì¨ Obteniendo mensajes de comunidad ${communityId}`);
        
        if (!isDatabaseConnected) {
          const fallbackMessages = [
            {
              id: 1,
              text: 'Mensaje de ejemplo (sin conexi√≥n a BD)',
              userName: 'Usuario Demo',
              timestamp: new Date().toISOString(),
              isOwn: false,
              userId: 1,
              imagenes: []
            }
          ];
          
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            data: fallbackMessages,
            message: 'Mensajes de respaldo (sin conexi√≥n)'
          }));
          return;
        }
        
        const messages = await communityQueries.getCommunityMessages(communityId);
        console.log(`‚úÖ ${messages.length} mensajes obtenidos`);
        
        res.writeHead(200);
        res.end(JSON.stringify({
          success: true,
          data: messages,
          message: 'Mensajes obtenidos exitosamente'
        }));
      } catch (error) {
        console.error('‚ùå Error obteniendo mensajes:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error interno del servidor',
          details: error.message
        }));
      }
      return;
    }

    // POST /api/communities/:id/messages - Enviar mensaje
    if (path.match(/\/api\/communities\/\d+\/messages$/) && method === 'POST') {
      const communityId = path.split('/')[3];
      
      let body = '';
      req.on('data', chunk => { body += chunk; });
      req.on('end', async () => {
        try {
          const { text } = JSON.parse(body || '{}');
          
          if (!text || !text.trim()) {
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'El mensaje no puede estar vac√≠o'
            }));
            return;
          }
          
          if (!isDatabaseConnected) {
            const fallbackMessage = {
              id: Date.now(),
              text: text,
              userName: 'T√∫',
              timestamp: new Date().toISOString(),
              isOwn: true,
              userId: 1,
              imagenes: []
            };
            
            res.writeHead(201);
            res.end(JSON.stringify({
              success: true,
              data: fallbackMessage,
              message: 'Mensaje enviado (offline)'
            }));
            return;
          }
          
          console.log('üì§ Enviando mensaje a comunidad', communityId);
          const newMessage = await communityQueries.sendMessage(communityId, text.trim());
          console.log('‚úÖ Mensaje enviado exitosamente');
          
          res.writeHead(201);
          res.end(JSON.stringify({
            success: true,
            data: {
              ...newMessage,
              isOwn: true,
              imagenes: []
            },
            message: 'Mensaje enviado exitosamente'
          }));
        } catch (error) {
          console.error('‚ùå Error enviando mensaje:', error);
          res.writeHead(400);
          res.end(JSON.stringify({
            success: false,
            error: error.message
          }));
        }
      });
      return;
    }

    // ===================
    // ENDPOINTS DE REPORTES (mantener los existentes)
    // ===================

    // GET /api/reports - Obtener todos los reportes
    if (path === '/api/reports' && method === 'GET') {
      try {
        console.log('üìã Obteniendo reportes...');
        
        if (!isDatabaseConnected) {
          console.log('‚ö†Ô∏è Base de datos no disponible, retornando datos de ejemplo');
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            reports: [
              {
                id: 'example-1',
                title: 'Ejemplo - Base de datos no disponible',
                description: 'Este es un reporte de ejemplo porque la base de datos no est√° disponible.',
                ubicacion: 'San Salvador, El Salvador',
                categoria: 'general',
                date: new Date().toISOString(),
                status: 'Pendiente',
                hasImage: false
              }
            ],
            count: 1,
            warning: 'Base de datos no disponible'
          }));
          return;
        }
        
        const sql = `
          SELECT 
            idReporte as id,
            titulo as title,
            descripcion as description,
            ubicacion,
            categoria,
            nombreImagen,
            tipoImagen,
            fechaCreacion as createdAt,
            CASE 
              WHEN nombreImagen IS NOT NULL THEN 1 
              ELSE 0 
            END as hasImage
          FROM reportes 
          ORDER BY fechaCreacion DESC
        `;
        
        const reports = await execute(sql);
        
        const processedReports = reports.map(report => ({
          ...report,
          status: 'Pendiente',
          date: report.createdAt,
          location: report.ubicacion || 'San Salvador, El Salvador',
          category: report.categoria || 'General',
          imageUrl: report.nombreImagen ? `/uploads/${report.nombreImagen}` : null
        }));
        
        res.writeHead(200);
        res.end(JSON.stringify({
          success: true,
          reports: processedReports,
          count: reports.length
        }));
      } catch (error) {
        console.error('‚ùå Error obteniendo reportes:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error al obtener reportes: ' + error.message
        }));
      }
      return;
    }

    // POST /api/reports - Crear nuevo reporte
    if (path === '/api/reports' && method === 'POST') {
      let body = '';
      let rawData = Buffer.alloc(0);
      
      const contentType = req.headers['content-type'] || '';
      
      req.on('data', chunk => { 
        rawData = Buffer.concat([rawData, chunk]);
        body += chunk.toString('binary');
      });
      
      req.on('end', async () => {
        try {
          // ‚úÖ AGREGAR DEBUG FORMDATA
          debugFormData(body, contentType);
          
          let reportData;
          
          if (contentType.includes('multipart/form-data')) {
            console.log('\nüìÅ Procesando FormData con posible imagen...');
            const fields = parseFormDataWithImage(body, contentType);
            
            reportData = {
              title: fields.title,
              description: fields.description,
              ubicacion: fields.ubicacion,
              categoria: fields.categoria,
              imageData: fields.imageData || null,
              imageName: fields.imageName || null,
              imageType: fields.imageType || null
            };
            
            console.log('\nüìã Datos extra√≠dos del formulario:');
            console.log(`üìù T√≠tulo: "${reportData.title}"`);
            console.log(`üìù Descripci√≥n: "${reportData.description}"`);
            console.log(`üìç Ubicaci√≥n: "${reportData.ubicacion}"`);
            console.log(`üè∑Ô∏è Categor√≠a: "${reportData.categoria}"`);
            console.log(`üì∑ Tiene imagen: ${!!reportData.imageData}`);
            
          } else {
            console.log('üìù Procesando datos JSON...');
            const data = JSON.parse(body || '{}');
            
            reportData = {
              title: data.title,
              description: data.description,
              ubicacion: data.ubicacion,
              categoria: data.categoria,
              imageData: null,
              imageName: null,
              imageType: null
            };
          }
          
          if (!reportData.title || !reportData.description || !reportData.ubicacion || !reportData.categoria) {
            console.log('‚ùå Validaci√≥n fallida - Campos faltantes');
            res.writeHead(400);
            res.end(JSON.stringify({
              success: false,
              error: 'Todos los campos son requeridos',
              received: {
                title: reportData.title || 'FALTANTE',
                description: reportData.description || 'FALTANTE',
                ubicacion: reportData.ubicacion || 'FALTANTE',
                categoria: reportData.categoria || 'FALTANTE'
              }
            }));
            return;
          }

          let finalImageName = null;
          if (reportData.imageData && reportData.imageName) {
            const imageSaved = saveImageToUploads(reportData.imageData, reportData.imageName);
            if (imageSaved) {
              finalImageName = reportData.imageName;
              console.log(`‚úÖ Imagen guardada en uploads: ${finalImageName}`);
            }
          }
          
          const sql = `
            INSERT INTO reportes (
              titulo, 
              descripcion, 
              ubicacion, 
              categoria, 
              imagen, 
              nombreImagen, 
              tipoImagen, 
              fechaCreacion
            ) VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
          `;
          
          const result = await execute(sql, [
            reportData.title,
            reportData.description,
            reportData.ubicacion,
            reportData.categoria,
            reportData.imageData,
            finalImageName,
            reportData.imageType
          ]);
          
          const newReport = {
            id: result.insertId,
            title: reportData.title,
            description: reportData.description,
            ubicacion: reportData.ubicacion,
            categoria: reportData.categoria,
            status: 'Pendiente',
            hasImage: !!finalImageName,
            imageName: finalImageName,
            imageType: reportData.imageType,
            imageUrl: finalImageName ? `/uploads/${finalImageName}` : null,
            date: new Date().toISOString()
          };
          
          res.writeHead(201);
          res.end(JSON.stringify({
            success: true,
            report: newReport,
            message: 'Reporte guardado exitosamente'
          }));
          
        } catch (error) {
          console.error('‚ùå Error creando reporte:', error);
          res.writeHead(400);
          res.end(JSON.stringify({
            success: false,
            error: 'Error al crear reporte: ' + error.message
          }));
        }
      });
      return;
    }

    // GET /api/reports/:id - Obtener reporte espec√≠fico
    if (path.startsWith('/api/reports/') && method === 'GET' && path.split('/').length === 4) {
      try {
        const reportId = path.split('/')[3];
        console.log(`üìÑ Obteniendo reporte ID: ${reportId}`);
        
        if (!isDatabaseConnected) {
          // Reporte de ejemplo
          const mockReport = {
            id: reportId,
            title: `Reporte ${reportId} (Ejemplo)`,
            description: 'Este es un reporte de ejemplo porque la base de datos no est√° disponible.',
            status: 'Pendiente',
            category: 'Sistema',
            hasImage: false,
            date: new Date().toISOString(),
            location: 'San Salvador, El Salvador'
          };
          
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            report: mockReport,
            warning: 'Base de datos no disponible'
          }));
          return;
        }
        
        const report = await reportQueries.getReportById(reportId);
        
        if (report) {
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            report: report
          }));
        } else {
          res.writeHead(404);
          res.end(JSON.stringify({
            success: false,
            error: 'Reporte no encontrado'
          }));
        }
      } catch (error) {
        console.error('‚ùå Error obteniendo reporte:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error al obtener reporte: ' + error.message
        }));
      }
      return;
    }

    // PUT /api/reports/:id - Actualizar reporte
    if (path.startsWith('/api/reports/') && method === 'PUT' && path.split('/').length === 4) {
      const reportId = path.split('/')[3];
      
      let body = '';
      req.on('data', chunk => { body += chunk; });
      req.on('end', async () => {
        try {
          const updates = JSON.parse(body || '{}');
          
          if (!isDatabaseConnected) {
            res.writeHead(200);
            res.end(JSON.stringify({
              success: true,
              message: 'Actualizaci√≥n simulada (base de datos no disponible)',
              warning: 'Los cambios no se guardaron permanentemente'
            }));
            return;
          }
          
          const updatedReport = await reportQueries.updateReport(reportId, updates);
          
          if (updatedReport) {
            console.log(`‚úÖ Reporte ${reportId} actualizado`);
            res.writeHead(200);
            res.end(JSON.stringify({
              success: true,
              report: updatedReport,
              message: 'Reporte actualizado exitosamente'
            }));
          } else {
            res.writeHead(404);
            res.end(JSON.stringify({
              success: false,
              error: 'Reporte no encontrado'
            }));
          }
        } catch (error) {
          console.error('‚ùå Error actualizando reporte:', error);
          res.writeHead(400);
          res.end(JSON.stringify({
            success: false,
            error: 'Error al actualizar reporte: ' + error.message
          }));
        }
      });
      return;
    }

    // DELETE /api/reports/:id - Eliminar reporte
    if (path.startsWith('/api/reports/') && method === 'DELETE' && path.split('/').length === 4) {
      try {
        const reportId = path.split('/')[3];
        console.log(`üóëÔ∏è Eliminando reporte ID: ${reportId}`);
        
        if (!isDatabaseConnected) {
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            message: 'Eliminaci√≥n simulada (base de datos no disponible)',
            warning: 'El reporte no se elimin√≥ permanentemente'
          }));
          return;
        }
        
        const deleted = await reportQueries.deleteReport(reportId);
        
        if (deleted) {
          console.log(`‚úÖ Reporte ${reportId} eliminado`);
          res.writeHead(200);
          res.end(JSON.stringify({
            success: true,
            message: 'Reporte eliminado exitosamente'
          }));
        } else {
          res.writeHead(404);
          res.end(JSON.stringify({
            success: false,
            error: 'Reporte no encontrado'
          }));
        }
      } catch (error) {
        console.error('‚ùå Error eliminando reporte:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error al eliminar reporte: ' + error.message
        }));
      }
      return;
    }

    // GET /api/reports/stats - Estad√≠sticas
    if (path === '/api/reports/stats' && method === 'GET') {
      try {
        const stats = await reportQueries.getStats();
        res.writeHead(200);
        res.end(JSON.stringify({
          success: true,
          stats: stats,
          databaseConnected: isDatabaseConnected
        }));
      } catch (error) {
        console.error('‚ùå Error obteniendo estad√≠sticas:', error);
        res.writeHead(500);
        res.end(JSON.stringify({
          success: false,
          error: 'Error al obtener estad√≠sticas: ' + error.message
        }));
      }
      return;
    }

    // 404 - Ruta no encontrada
    console.log('‚ùå Ruta no encontrada:', path);
    res.writeHead(404);
    res.end(JSON.stringify({
      success: false,
      error: 'Ruta no encontrada',
      path: path,
      method: method,
      availableRoutes: [
        // Rutas b√°sicas
        'GET /',
        'GET /api/test',
        
        // Rutas de autenticaci√≥n  
        'POST /api/auth/login',
        'POST /api/auth/register',
        'GET /api/auth/test',
        'GET /api/users',
        'GET /api/users/:id',
         'PUT /api/users/:id',           // ‚úÖ AGREGAR ESTA
        'PUT /api/users/:id/password',  // ‚úÖ AGREGAR ESTA
        
        // Rutas de comunidades
        'GET /api/communities',
        'POST /api/communities',
        'POST /api/communities/action',
        'GET /api/communities/test/connection',
        'GET /api/communities/user',
        'GET /api/communities/:id',
        'GET /api/communities/:id/messages',
        'POST /api/communities/:id/messages',
        
        // Rutas de reportes
        'GET /api/reports',
        'POST /api/reports',
        'GET /api/reports/:id',
        'PUT /api/reports/:id',
        'DELETE /api/reports/:id',
        'GET /api/reports/stats'
      ]
    }));

  } catch (error) {
    console.error('üí• Error general del servidor:', error);
    res.writeHead(500);
    res.end(JSON.stringify({
      success: false,
      error: 'Error interno del servidor: ' + error.message
    }));
  }
});

// Funci√≥n para inicializar el servidor
async function initializeServer() {
  console.log('\n' + '='.repeat(60));
  console.log('üöÄ Iniciando Mi Ciudad SV Backend Server');
  console.log('='.repeat(60));
  
  // Intentar conectar a la base de datos
  try {
    isDatabaseConnected = await connectDB();
    if (isDatabaseConnected) {
      console.log('‚úÖ Base de datos MySQL conectada exitosamente');
      
      // Verificar las tablas
      try {
        const stats = await reportQueries.getStats();
        console.log(`üìä Reportes en la base de datos: ${stats.total}`);
        
        // Verificar comunidades
        const communities = await communityQueries.getAllCommunities();
        console.log(`üèòÔ∏è Comunidades en la base de datos: ${communities.length}`);
      } catch (error) {
        console.warn('‚ö†Ô∏è Advertencia: No se pudieron obtener estad√≠sticas iniciales');
      }
    } else {
      console.log('‚ö†Ô∏è Continuando sin base de datos - Modo desarrollo');
    }
  } catch (error) {
    console.error('‚ùå Error conectando a la base de datos:', error.message);
    console.log('‚ö†Ô∏è El servidor funcionar√° sin persistencia de datos');
    isDatabaseConnected = false;
  }
  
  // Iniciar servidor HTTP
  server.listen(PORT, '0.0.0.0', (error) => {
    if (error) {
      console.error('üí• Error al iniciar servidor HTTP:', error);
      process.exit(1);
    }
    
    console.log('='.repeat(60));
    console.log(`üì± Local:        http://localhost:${PORT}`);
    console.log(`üåê Network:      http://192.168.1.13:${PORT}`);
    console.log(`üì° API Test:     http://192.168.1.13:${PORT}/api/test`);
    console.log(`üîê Auth Test:    http://192.168.1.13:${PORT}/api/auth/test`);
    console.log(`üë• Users:        http://192.168.1.13:${PORT}/api/users`);
    console.log(`üìã Reports:      http://192.168.1.13:${PORT}/api/reports`);
    console.log(`üèòÔ∏è Communities:  http://192.168.1.13:${PORT}/api/communities`);
    console.log('='.repeat(60));
    console.log(`‚úÖ Servidor HTTP corriendo en puerto ${PORT}`);
    console.log(`üíæ Estado DB: ${isDatabaseConnected ? 'Conectada' : 'Desconectada'}`);
    console.log('üìù Listo para recibir peticiones...\n');
  });
}

// Manejar cierre graceful del servidor
process.on('SIGINT', async () => {
  console.log('\nüõë Cerrando servidor...');
  
  if (isDatabaseConnected && pool) {
    try {
      await pool.end();
      console.log('‚úÖ Pool de conexiones cerrado');
    } catch (error) {
      console.error('‚ùå Error cerrando pool:', error);
    }
  }
  
  console.log('üëã Servidor cerrado exitosamente');
  process.exit(0);
});

// Manejar errores no capturados
process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  process.exit(1);
});

// Inicializar servidor
initializeServer();

module.exports = server;




// hooks/useAuth.js - VERSI√ìN CORREGIDA CON updateUserContext
import React, { createContext, useContext, useState, useEffect } from 'react';
import authService from '../services/authService';

// Crear el contexto de autenticaci√≥n
const AuthContext = createContext({});

// Provider del contexto de autenticaci√≥n
export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  // Verificar sesi√≥n al iniciar la app
  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      console.log('üîç Checking authentication status...');
      const session = await authService.getUserSession();
      
      if (session && session.user) {
        console.log('‚úÖ User session found:', session.user.nombre);
        setUser(session.user);
        setIsAuthenticated(true);
      } else {
        console.log('‚ùå No user session found');
        setUser(null);
        setIsAuthenticated(false);
      }
    } catch (error) {
      console.error('‚ùå Error checking auth status:', error);
      setUser(null);
      setIsAuthenticated(false);
    } finally {
      setIsLoading(false);
      console.log(isAuthenticated ? '‚úÖ User is authenticated' : '‚ùå User is not authenticated');
    }
  };

  // FUNCI√ìN LOGIN CORREGIDA - CR√çTICA
  const login = async (email, password) => {
    try {
      console.log('üîê === useAuth.login called ===');
      console.log('üìß Email received:', email);
      console.log('üîë Password received:', password ? 'YES' : 'NO');
      console.log('üîë Password length:', password ? password.length : 0);

      // Validaci√≥n en el hook
      if (!email) {
        throw new Error('Email es requerido');
      }

      if (!password) {
        throw new Error('Contrase√±a es requerida');
      }

      // LLAMADA CORREGIDA - Pasar ambos par√°metros expl√≠citamente
      console.log('üìû Calling authService.login with:', email, password ? `[${password.length} chars]` : 'NO PASSWORD');
      
      const result = await authService.login(email, password);
      
      console.log('‚úÖ Login successful in useAuth:', result);

      if (result.success && result.user) {
        setUser(result.user);
        setIsAuthenticated(true);
        console.log('üéâ User authenticated successfully:', result.user.nombre);
        return result;
      } else {
        throw new Error(result.error || 'Login failed');
      }
    } catch (error) {
      console.log('‚ùå Login failed in useAuth:', error.message);
      setUser(null);
      setIsAuthenticated(false);
      throw error;
    }
  };

  // ‚úÖ NUEVA FUNCI√ìN: Actualizar contexto de usuario
  const updateUserContext = async (updatedUser) => {
    try {
      console.log('üîÑ === UPDATING USER CONTEXT ===');
      console.log('üë§ Old user data:', user);
      console.log('üÜï New user data:', updatedUser);
      
      // Actualizar el estado del contexto inmediatamente
      setUser(updatedUser);
      console.log('‚úÖ User state updated in context');
      
      // Tambi√©n actualizar la sesi√≥n en AsyncStorage para persistencia
      try {
        const currentSession = await authService.getUserSession();
        if (currentSession && currentSession.token) {
          await authService.saveUserSession(updatedUser, currentSession.token);
          console.log('‚úÖ User session updated in AsyncStorage');
        } else {
          // Si no hay token, usar uno temporal
          await authService.saveUserSession(updatedUser, 'updated-token');
          console.log('‚úÖ User session saved with temporary token');
        }
      } catch (storageError) {
        console.warn('‚ö†Ô∏è Warning updating storage:', storageError);
        // No fallar por error de storage
      }
      
      console.log('üéâ User context update completed successfully');
      return true;
      
    } catch (error) {
      console.error('‚ùå Error updating user context:', error);
      return false;
    }
  };

  const logout = async () => {
    try {
      console.log('üö™ Logging out...');
      await authService.logout();
      setUser(null);
      setIsAuthenticated(false);
      console.log('‚úÖ Logout successful');
    } catch (error) {
      console.error('‚ùå Logout error:', error);
      // Forzar logout local aunque falle el servidor
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  const value = {
    user,
    isAuthenticated,
    isLoading,
    login,
    logout,
    checkAuthStatus,
    updateUserContext // ‚úÖ NUEVA FUNCI√ìN AGREGADA
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

// Hook para usar el contexto
export const useAuth = () => {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
};

export default { AuthProvider, useAuth };